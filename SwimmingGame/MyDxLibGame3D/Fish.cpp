#include "Fish.h"
#include "Common.h"
#include "Jump.h"
#include"Input.h"

/// <summary>
/// コンストラクタ
/// </summary>
Fish::Fish(int _sourceModelHandle,
	VECTOR _pos, VECTOR _rotate, VECTOR _dancePos)
	:FishBase(_sourceModelHandle)
	, mJumpUpdataFlag(false)
	, mJumpedInFlag(false)
{
	mPos = _pos;
	mRotate = _rotate;
	mSetDancePos = _dancePos;

	mMoveState = NotMove;

	mJump = new Jump();
}

/// <summary>
/// デストラクタ
/// </summary>
Fish::~Fish()
{
	//処理なし
}

/// <summary>
/// 更新関数
/// </summary>
void Fish::Updata()
{
	//動いているときに
	if (mMoveState == NowMove)
	{
		// ポジションの更新をする
		mPos = VAdd(mPos, mVelocity);
	}

	if (!mJumpedInFlag)
	{
		//飛び込みの処理
		JumpUpdata();
	}
	else
	{
		//アーティスティックスイミングの処理
		DanceUpdata();
	}
}

/// <summary>
/// ジャンプの更新を入れた関数 : @saito
/// </summary>
void Fish::JumpUpdata()
{
	// 全てのジャンプが終わっていない状態で
	// ボタンが押されたら、またはtimingゲージが縮小し終わったらジャンプする（ってしたい）
	if (mJump->GetNowJump() != mJump->endJump &&
		(Key[KEY_INPUT_SPACE] == 1 && mJump->GetIsGround())/*||
		(mTiming->GetRadius() <= 1 && mJump->GetIsGround())*/)
	{
		// ジャンプの更新をするようにする
		mJumpUpdataFlag = true;
	}

	if (mJumpUpdataFlag)
	{
		//ジャンプの更新
		mJump->JumpUpdate(mRotate);

		// 今のジャンプが飛び込みじゃない、かつ、増加量が0になったら
		if (mJump->GetNowJump() != mJump->thirdJump && mJump->GetGain() <= 0.0f)
		{
			// ジャンプパターンを更新する
			mJump->JumpSetUpdate();
			// ジャンプの更新を止める
			mJumpUpdataFlag = false;
		}
		// 今のジャンプが飛び込みで、プールのところまでいったら
		else if (mJump->GetNowJump() == mJump->thirdJump && mPos.y <= 0.0f)
		{
			// ジャンプパターンを更新する
			mJump->JumpSetUpdate();

			// 押し戻し…？
			mPos.y = 0.0f;

			// ジャンプの更新を止める
			mJumpUpdataFlag = false;

			//ジャンプの更新処理が終わったことを示すためtrueにする
			mJumpedInFlag = true;
		}
	}

	mMoveState = NowMove;
	mVelocity = mJump->GetVelocity();
}


/// <summary>
/// アーティスティックスイミング時の更新処理を入れた関数
/// </summary>
void Fish::DanceUpdata()
{
	mVelocity = MoveTargetPos(mSetDancePos, mPos, mRotate);
}


//andou
/// <summary>
///  目標の座標まで移動する関数
/// </summary>
/// <param name="_mSetPos">ダンス集合時のポジション</param>
/// <param name="_mNowPos">モデルの現在のポジション</param>
/// <param name="_Rotate">魚が向いている方向のベクトル</param>
/// <returns>動いているときはfalse、動いていないときはtrueを返す</returns>
VECTOR Fish::MoveTargetPos(const VECTOR _SetPos, VECTOR& _NowPos, VECTOR& _Rotate)
{
	//移動ベクトルの計算
	VECTOR posToSetPos = VSub(_SetPos, _NowPos);
	VECTOR normPosToSetPos = VNorm(posToSetPos);
	mVelocity = VScale(normPosToSetPos, SET_DANCE_POS_VELOCITY);

	//止まるとき
	if (CheckStopped(_SetPos, _NowPos))
	{
		mMoveState = NotMove;
		return mVelocity;
	}
	else
	{
		mMoveState = NowMove;
		return mVelocity;
	}
}


/// <summary>
/// 移動したときに指定の位置に着いたかどうか
/// </summary>
/// <param name="_targetPos">指定した位置</param>
/// <param name="_nowPos">今のモデルの位置</param>
/// <returns>止まっていい時はtrue、止まってはいけない時はfalse</returns>
bool Fish::CheckStopped(const VECTOR _targetPos, const VECTOR _nowPos)
{
	VECTOR posToSetPos = VSub(_targetPos, _nowPos);
	VECTOR normPosToSetPos = VNorm(posToSetPos);

	/*-----------モデルを止めるために停止範囲の距離の計算----------*/

	//mPosからmSetDancePosまでの距離の計算
	float PosSize = VSquareSize(posToSetPos);

	VECTOR StopRange = VScale(normPosToSetPos, SET_DANCE_POS_RANGE);

	//mSetDancePosからmStoprangeまでの距離の計算
	VECTOR normSetPosToPos = VNorm(VSub(_nowPos, _targetPos));
	StopRange = VScale(normSetPosToPos, SET_DANCE_POS_RANGE);

	float mStopRadiusSize = VSquareSize(StopRange);

	//mSetPosからmPosまでのベクトルの長さ(値は2乗)が
	//mSetPosからmStopRadiusまでのベクトルの長さ(値は2乗)より
	//大きい時に移動させる
	if (PosSize > mStopRadiusSize)
	{
		return false;
	}
	else if (PosSize <= mStopRadiusSize)
	{
		return true;
	}
}